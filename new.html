<!DOCTYPE html>
<html>
<head>
    <title>Pixelate!</title>
    <style>
        canvas {
            width: 400px;
        }
    </style>
</head>
<body>
    <input type="file" id="imageInput" accept="image/*">
    <input type="number" id="desiredWidth" placeholder="Width" min="1" oninput="clearHeight()">
    <input type="number" id="desiredHeight" placeholder="Height" min="1" oninput="clearWidth()">
    <button id="compressButton">Pixelate!</button>
    <br>
    <canvas id="originalCanvas"></canvas>
    <canvas id="compressedCanvas"></canvas>

    <script>
        document.getElementById('imageInput').addEventListener('change', handleImageUpload);
        document.getElementById('compressButton').addEventListener('click', pixelateImage);

        let img = new Image();
        let originalCanvas = document.getElementById('originalCanvas');
        let originalCtx = originalCanvas.getContext('2d');

        function handleImageUpload(event) {
            const file = event.target.files[0];
            const reader = new FileReader();

            reader.onload = function(e) {
                img.onload = function() {
                    originalCanvas.width = img.width;
                    originalCanvas.height = img.height;
                    originalCtx.drawImage(img, 0, 0);
                };
                img.src = e.target.result;
            };

            reader.readAsDataURL(file);
        }

        function clearWidth() {
            document.getElementById('desiredWidth').value = '';
        }

        function clearHeight() {
            document.getElementById('desiredHeight').value = '';
        }

        function pixelateImage() {
            const desiredWidth = parseInt(document.getElementById('desiredWidth').value);
            const desiredHeight = parseInt(document.getElementById('desiredHeight').value);

            if (isNaN(desiredWidth) && isNaN(desiredHeight)) {
                alert("Please enter a valid desired width or height greater than 0.");
                return;
            }

            let scaleFactor;
            if (!isNaN(desiredWidth)) {
                scaleFactor = img.width / desiredWidth;
            } else if (!isNaN(desiredHeight)) {
                scaleFactor = img.height / desiredHeight;
            }

            const newWidth = Math.floor(img.width / scaleFactor);
            const newHeight = Math.floor(img.height / scaleFactor);

            const imageData = originalCtx.getImageData(0, 0, img.width, img.height);
            const pixels = imageData.data;

            const compressedCanvas = document.getElementById('compressedCanvas');
            const compressedCtx = compressedCanvas.getContext('2d');
            compressedCanvas.width = img.width;
            compressedCanvas.height = img.height;

            for (let y = 0; y < newHeight; y++) {
                for (let x = 0; x < newWidth; x++) {
                    let r = 0, g = 0, b = 0, a = 0;
                    let count = 0;

                    for (let ky = 0; ky < scaleFactor; ky++) {
                        for (let kx = 0; kx < scaleFactor; kx++) {
                            const originalX = Math.floor(x * scaleFactor + kx);
                            const originalY = Math.floor(y * scaleFactor + ky);
                            if (originalX < img.width && originalY < img.height) {
                                const index = (originalY * img.width + originalX) * 4;
                                r += pixels[index];
                                g += pixels[index + 1];
                                b += pixels[index + 2];
                                a += pixels[index + 3];
                                count++;
                            }
                        }
                    }

                    r = r / count;
                    g = g / count;
                    b = b / count;
                    a = a / count;

                    // Draw the averaged color block
                    compressedCtx.fillStyle = `rgba(${r},${g},${b},${a / 255})`;
                    compressedCtx.fillRect(x * scaleFactor, y * scaleFactor, Math.ceil(scaleFactor), Math.ceil(scaleFactor));
                }
            }
        }
    </script>
</body>
</html>
